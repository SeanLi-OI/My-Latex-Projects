\chapter{结论和总结}
\section{对本算法的总结与思考}
本算法充分利用两文本相似度较高的特点，尽可能减少需计算状态，其实相当于利用LCS较长的结论来反推LCS解从而提高算法效率，给我们的启示是对于一个抽象出来的问题，如果正着做比较复杂，不如思考一下能否将问题取反或是找其时间复杂度较低的等价问题，就如对于一个流量网络，最小割的值不好求，但可以证明最小割的值等于最大流的值，而求最大流的复杂度低于求最小割。
\section{对LCS一类的DP问题的思考}
有了以上的思路，对于LCS问题，我们可以将其转化为LIS（最长上升子序列）问题求解。
举个例子
假设有两个序列
$s1[1~6]=\{a,b,c,a,d,c\}$, $s2[1~7]=\{c,a,b,e,d,a,b\}$
记录s1中每个元素在s2中出现的位置, 再将位置按降序排列, 则上面的例子可表示为：
$loc(a)=\{6,2\}, loc(b)=\{7,3\},loc(c)=\{1\},loc(d)=\{5\}$
将s1中每个元素的位置按s1中元素的顺序排列成一个序列
$s3=\{6,2,7,3,1,6,2,5,1\}$。
在对s3求LIS得到的值即为求LCS的答案。
\par
我们已知LIS算法的时间复杂度为$O(n\log n)$，则LCS问题在字符重复度较小的情况下其时间复杂度也近似$O(n\log n)$\cite{Kuo1989An}。